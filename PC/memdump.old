//**********************************************************************************//
//								USB Gecko Memory Tool								//
//				For Uploading and Downloading from Gamecube / Wii Memory			//
//**********************************************************************************//
#include <stdio.h>
#include <stdlib.h>
#include "stdafx.h"
#include "ftd2xx.h"


#define ENDIANFLIP(a) (((a) & 0x000000FF) << 24 | ((a) & 0x0000FF00) << 8 | ((a) & 0x00FF0000) >> 8) | (((a) & 0xFF000000) >> 24)

int geckoread(LPVOID lpBuffer, DWORD dwBytesToRead, LPDWORD lpdwBytesReturned);
int geckowrite(LPVOID lpBuffer, DWORD dwBytesToWrite, LPDWORD lpdwBytesWritten);
void progusage();
int ReadDVD (char *rmemfile);

void opengecko();

	// FTDI Variables
	FT_HANDLE fthandle;	// Handle of the device to be opened and used for all functions
	FT_STATUS status;	// Variable needed for FTDI Library functions
	DWORD TxSent;
	DWORD RxSent;
	DWORD RXqueue;		// Pointer to DWORD RXqueue
	FILE *fp;
	FILE *logf;
	FILE *bads;
	// Read DWORD variables
	DWORD RXbytes,TXbytes,Eventdword;
	char *readdvdfile;
	int returnvalue;
	// my vars
	unsigned char GCDVD = 0x61;
	unsigned char GCMORE = 0x62;
	unsigned char GCEND = 0x63;
	unsigned char GCCHK = 0x64;
	unsigned char AGAIN = 0x65;
	typedef struct {
		unsigned char dvd_data[63448];
	} data_packet;
long convert_long(long in);

int main (int argc, char *argv[])	// Argument count and vectors
{
		
		printf("USB Gecko DVD DUMPING Tool V1.0 - www.usbgecko.com -\n\n");
				
			if (argc < 2)
			{
				progusage();	// Show program usage
				return(0);	// Exit
			}
			
			if (argc >= 2)
			{
				readdvdfile = argv[1];		// Store filename for later
			}
	

	// Set Timeouts
      	opengecko();
		printf("Connecting to USB Gecko.\n");
		printf("Connected to Gamecube / Wii Console\n");	// Connected & Ready
	
		ReadDVD(readdvdfile);
		
		status = FT_Close(fthandle);
		return (0);	// Display and return

}

void progusage()
{
	printf("Usage:\n");
	printf("dvddump <File>  - Dump DVD to file\n");
	printf("Example: dvddump gcbackup.iso\n");
}

int ReadDVD (char *rmemfile)
{
	int returnvalue = 0;
	int checkvalue = 0;
	unsigned long total_sectors = 0;
    int lastchunk = 0;
	int totalkb = 0;
	int usb_packet_size = 63448;
	int dvd_packet_size = 63448;
	unsigned int cur_offset = 0;
	unsigned int cur_sector = 0;
	data_packet data;

	// Open File
	fp = fopen((const char *) rmemfile, "wb");
	if (!fp)							
	{
		printf("Error: Problem creating file\n");
		status = FT_Close(fthandle);		// Close device if file error
		return(0);
	}

	// Send the Dump DVD Start command
	returnvalue = geckowrite(&GCDVD, 1, &TxSent);
	if(returnvalue <= 0)
	{
		fclose(fp);
		return(0);
	}

	printf("Waiting for GC..\n");
	while(total_sectors == 0) {
		returnvalue = geckoread(&total_sectors, 4, &RxSent);
		if(returnvalue<=0) {
			fclose(fp);
			return(0);
		}
	}

	total_sectors = convert_long(total_sectors);
	switch(total_sectors) {
	case 0x46090000:
		printf("Wii disc detected\n");
		break;
	case 0x15C16000:
		printf("GC disc detected\n");
		break;
	default:
		fclose(fp);
		printf("Error detecting type of disc\n");
		return(0);
		break;
	}

	// Send the ok command
	printf("Telling the GC to start\n");
	returnvalue = geckowrite(&GCCHK, 1, &TxSent);
	if(returnvalue <= 0)	{
		fclose(fp);
		return(0);
	}

	unsigned int total_offset = total_sectors*4;
    lastchunk  = (total_offset % dvd_packet_size);		// get remainder chunk size
	totalkb = ((total_sectors*4)/1024);

	while(cur_offset<total_offset) 
	{
		// update the display in the command window every 2%
		if((cur_offset%1015168) == 0)
		{
			system("cls");
			printf("Received...  ");
			printf("%i/%i completed",cur_offset/1024,totalkb);
		}

		//read from GC: dvddata(dvd_data_size)+crc(4)
		returnvalue = geckoread(&data, usb_packet_size, &RxSent);
		if(returnvalue!=1) 
		{
			printf("error: %i\n",returnvalue);
			fclose(fp);
			return(0);
		}

		//write to file
		fwrite(&data.dvd_data, 1, dvd_packet_size, fp);
		if(ferror(fp))
		{
			printf("Error: Problem writing to file\n");		// Error writing packet
			status = FT_Close(fthandle);	// So close device
			fclose(fp);						// Close file
			return(0);
		}	
		fflush(fp);

		// Send the OK command
		returnvalue = geckowrite(&GCCHK, 1, &TxSent);
		if(returnvalue <= 0)
		{
			fclose(fp);
			return(0);
		}
		cur_offset+=dvd_packet_size;
	}
	if (lastchunk>0) 
	{
		//read out the last chunk
		returnvalue = geckoread(&data.dvd_data, lastchunk, &RxSent);
		if(returnvalue<=0) 
		{
			fclose(fp);
			return(0);
		}
		//write out the last chunk
		fwrite(&data.dvd_data, 1, lastchunk, fp);
		if(ferror(fp))
		{
			printf("Error: Problem writing to file\n");		// Error writing packet
			status = FT_Close(fthandle);	// So close device
			fclose(fp);						// Close file
			return(0);
		}
	}
		
	fclose(fp);	
	fclose(logf);	
	printf("\n\nDone! \n");
	return 0;
	
}

void opengecko()
{

		// Open by Serial Number
		status = FT_OpenEx("GECKUSB0", FT_OPEN_BY_SERIAL_NUMBER, &fthandle);
			if(status != FT_OK) 
				{
				printf("Error: Couldn't connect to USB Gecko. Please check Installation\n");
				exit(0);
				}
		// Reset device			
		status = FT_ResetDevice(fthandle);
			if(status != FT_OK)
				{
				printf("Error: Couldnt Reset Device %d\n",status);
				status = FT_Close(fthandle);
				exit(0);
				}

		status = FT_SetTimeouts(fthandle,1000,1000);	// 3 Second Timeout
			if(status != FT_OK)
				{
				printf("Error: Timeouts failed to set %d\n",status);
				status = FT_Close(fthandle);
				exit(0);
				}	
		// Purge buffers		
		status = FT_Purge(fthandle,FT_PURGE_RX);
			if(status != FT_OK)
				{
				printf("Error: Problem clearing buffers %d\n",status);
				status = FT_Close(fthandle);
				exit(0);
				}
		status = FT_Purge(fthandle,FT_PURGE_TX);
			if(status != FT_OK)
				{
				printf("Error: Problem clearing buffers %d\n",status);
				status = FT_Close(fthandle);
				exit(0);
				}

		status = FT_SetUSBParameters(fthandle,65536,0);	// Set to 64K packet size (USB 2.0 Max)
			if(status != FT_OK)
				{
				printf("Error: Couldnt Set USB Parameters %d\n",status);
				status = FT_Close(fthandle);
				exit(0);
				}
		Sleep(150);
}

int geckoread(LPVOID lpBuffer, DWORD dwBytesToRead, LPDWORD lpdwBytesReturned)
{
	status = FT_Read(fthandle, lpBuffer, dwBytesToRead, lpdwBytesReturned);	// Read in the data
	
	if (status != FT_OK)	// Check read ok
	{
		printf("Error: Read Error. Closing\n");
		status = FT_Close(fthandle);	// Close device as fatal error
		return 0;
	}
	return 1;	// return 1 everything read ok
		
}


int geckowrite(LPVOID lpBuffer, DWORD dwBytesToWrite, LPDWORD lpdwBytesWritten)
{

	status = FT_Write(fthandle, lpBuffer, dwBytesToWrite, lpdwBytesWritten);	// Read in the data
	
	if (status != FT_OK)	// Check read ok
	{
		printf("Error: Write Error. Closing.\n");
		status = FT_Close(fthandle);	// Close device as fatal error
		return 0;
	}
		
	return 1;	// return 1 everything read ok
}


unsigned int checksum(data_packet *d)
{ 
	unsigned int i = 0; 
    unsigned int c = 0;
    for (i = 0;i<sizeof(d->dvd_data);i++) 
    { 
		if(d->dvd_data[i]==0)
			c+=0xFF;
		if(d->dvd_data[i]>0x80)
			c+=d->dvd_data[i]*3;
		c+=d->dvd_data[i];
    } 
    return c;
} 

long convert_long(long in)
{
  long out;
  char *p_in = (char *) &in;
  char *p_out = (char *) &out;
  p_out[0] = p_in[3];
  p_out[1] = p_in[2];
  p_out[2] = p_in[1];
  p_out[3] = p_in[0];  
  return out;
}
